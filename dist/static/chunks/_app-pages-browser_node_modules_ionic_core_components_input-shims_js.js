"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_ionic_core_components_input-shims_js"],{

/***/ "(app-pages-browser)/./node_modules/@ionic/core/components/input-shims.js":
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/components/input-shims.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startInputShims: function() { return /* binding */ startInputShims; }\n/* harmony export */ });\n/* harmony import */ var _index5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index5.js */ \"(app-pages-browser)/./node_modules/@ionic/core/components/index5.js\");\n/* harmony import */ var _index8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index8.js */ \"(app-pages-browser)/./node_modules/@ionic/core/components/index8.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@ionic/core/components/helpers.js\");\n/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard.js */ \"(app-pages-browser)/./node_modules/@ionic/core/components/keyboard.js\");\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\nconst cloneMap = new WeakMap();\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {\n    if (cloneMap.has(componentEl) === shouldRelocate) {\n        return;\n    }\n    if (shouldRelocate) {\n        addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);\n    }\n    else {\n        removeClone(componentEl, inputEl);\n    }\n};\nconst isFocused = (input) => {\n    /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n     * Calling getRootNode on an element in standard web page will return HTMLDocument.\n     * Calling getRootNode on an element inside of the Shadow DOM will return the associated ShadowRoot.\n     * Calling getRootNode on an element that is not attached to a document/shadow tree will return\n     * the root of the DOM tree it belongs to.\n     * isFocused is used for the hide-caret utility which only considers input/textarea elements\n     * that are present in the DOM, so we don't set types for that final case since it does not apply.\n     */\n    return input === input.getRootNode().activeElement;\n};\nconst addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {\n    // this allows for the actual input to receive the focus from\n    // the user's touch event, but before it receives focus, it\n    // moves the actual input to a location that will not screw\n    // up the app's layout, and does not allow the native browser\n    // to attempt to scroll the input into place (messing up headers/footers)\n    // the cloned input fills the area of where native input should be\n    // while the native input fakes out the browser by relocating itself\n    // before it receives the actual focus event\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\n    const parentEl = inputEl.parentNode;\n    // DOM WRITES\n    const clonedEl = inputEl.cloneNode(false);\n    clonedEl.classList.add('cloned-input');\n    clonedEl.tabIndex = -1;\n    /**\n     * Making the cloned input disabled prevents\n     * Chrome for Android from still scrolling\n     * the entire page since this cloned input\n     * will briefly be hidden by the keyboard\n     * even though it is not focused.\n     *\n     * This is not needed on iOS. While this\n     * does not cause functional issues on iOS,\n     * the input still appears slightly dimmed even\n     * if we set opacity: 1.\n     */\n    if (disabledClonedInput) {\n        clonedEl.disabled = true;\n    }\n    parentEl.appendChild(clonedEl);\n    cloneMap.set(componentEl, clonedEl);\n    const doc = componentEl.ownerDocument;\n    const tx = doc.dir === 'rtl' ? 9999 : -9999;\n    componentEl.style.pointerEvents = 'none';\n    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\n};\nconst removeClone = (componentEl, inputEl) => {\n    const clone = cloneMap.get(componentEl);\n    if (clone) {\n        cloneMap.delete(componentEl);\n        clone.remove();\n    }\n    componentEl.style.pointerEvents = '';\n    inputEl.style.transform = '';\n};\n/**\n * Factoring in 50px gives us some room\n * in case the keyboard shows password/autofill bars\n * asynchronously.\n */\nconst SCROLL_AMOUNT_PADDING = 50;\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\n    if (!scrollEl || !inputEl) {\n        return () => {\n            return;\n        };\n    }\n    const scrollHideCaret = (shouldHideCaret) => {\n        if (isFocused(inputEl)) {\n            relocateInput(componentEl, inputEl, shouldHideCaret);\n        }\n    };\n    const onBlur = () => relocateInput(componentEl, inputEl, false);\n    const hideCaret = () => scrollHideCaret(true);\n    const showCaret = () => scrollHideCaret(false);\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollStart', hideCaret);\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.addEventListener('blur', onBlur);\n    return () => {\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollStart', hideCaret);\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollEnd', showCaret);\n        inputEl.removeEventListener('blur', onBlur);\n    };\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\nconst enableInputBlurring = () => {\n    let focused = true;\n    let didScroll = false;\n    const doc = document;\n    const onScroll = () => {\n        didScroll = true;\n    };\n    const onFocusin = () => {\n        focused = true;\n    };\n    const onTouchend = (ev) => {\n        // if app did scroll return early\n        if (didScroll) {\n            didScroll = false;\n            return;\n        }\n        const active = doc.activeElement;\n        if (!active) {\n            return;\n        }\n        // only blur if the active element is a text-input or a textarea\n        if (active.matches(SKIP_SELECTOR)) {\n            return;\n        }\n        // if the selected target is the active element, do not blur\n        const tapped = ev.target;\n        if (tapped === active) {\n            return;\n        }\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n            return;\n        }\n        focused = false;\n        // TODO FW-2796: find a better way, why 50ms?\n        setTimeout(() => {\n            if (!focused) {\n                active.blur();\n            }\n        }, 50);\n    };\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(doc, 'ionScrollStart', onScroll);\n    doc.addEventListener('focusin', onFocusin, true);\n    doc.addEventListener('touchend', onTouchend, false);\n    return () => {\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(doc, 'ionScrollStart', onScroll, true);\n        doc.removeEventListener('focusin', onFocusin, true);\n        doc.removeEventListener('touchend', onTouchend, false);\n    };\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\nconst getScrollData = (componentEl, contentEl, keyboardHeight, platformHeight) => {\n    var _a;\n    const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, platformHeight);\n};\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\n    // compute input's Y values relative to the body\n    const inputTop = inputRect.top;\n    const inputBottom = inputRect.bottom;\n    // compute visible area\n    const visibleAreaTop = contentRect.top;\n    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n    // compute safe area\n    const safeAreaTop = visibleAreaTop + 15;\n    const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;\n    // figure out if each edge of the input is within the safe area\n    const distanceToBottom = safeAreaBottom - inputBottom;\n    const distanceToTop = safeAreaTop - inputTop;\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n    const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n    // gets focus, so make sure we don't scroll the input above the visible area\n    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n    const distance = Math.abs(scrollAmount);\n    const duration = distance / SCROLL_ASSIST_SPEED;\n    const scrollDuration = Math.min(400, Math.max(150, duration));\n    return {\n        scrollAmount,\n        scrollDuration,\n        scrollPadding: keyboardHeight,\n        inputSafeY: -(inputTop - safeAreaTop) + 4,\n    };\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\n/**\n * Scroll padding adds additional padding to the bottom\n * of ion-content so that there is enough scroll space\n * for an input to be scrolled above the keyboard. This\n * is needed in environments where the webview does not\n * resize when the keyboard opens.\n *\n * Example: If an input at the bottom of ion-content is\n * focused, there is no additional scrolling space below\n * it, so the input cannot be scrolled above the keyboard.\n * Scroll padding fixes this by adding padding equal to the\n * height of the keyboard to the bottom of the content.\n *\n * Common environments where this is needed:\n * - Mobile Safari: The keyboard overlays the content\n * - Capacitor/Cordova on iOS: The keyboard overlays the content\n * when the KeyboardResize mode is set to 'none'.\n */\nconst setScrollPadding = (contentEl, paddingAmount, clearCallback) => {\n    const timer = contentEl[PADDING_TIMER_KEY];\n    if (timer) {\n        clearTimeout(timer);\n    }\n    if (paddingAmount > 0) {\n        contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);\n    }\n    else {\n        contentEl[PADDING_TIMER_KEY] = setTimeout(() => {\n            contentEl.style.setProperty('--keyboard-offset', '0px');\n            if (clearCallback) {\n                clearCallback();\n            }\n        }, 120);\n    }\n};\n/**\n * When an input is about to be focused,\n * set a timeout to clear any scroll padding\n * on the content. Note: The clearing\n * is done on a timeout so that if users\n * are moving focus from one input to the next\n * then re-adding scroll padding to the new\n * input with cancel the timeout to clear the\n * scroll padding.\n */\nconst setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {\n    const clearScrollPadding = () => {\n        if (contentEl) {\n            setScrollPadding(contentEl, 0, doneCallback);\n        }\n    };\n    inputEl.addEventListener('focusout', clearScrollPadding, { once: true });\n};\n\nlet currentPadding = 0;\nconst SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {\n    /**\n     * Scroll padding should only be added if:\n     * 1. The global scrollPadding config option\n     * is set to true.\n     * 2. The native keyboard resize mode is either \"none\"\n     * (keyboard overlays webview) or undefined (resize\n     * information unavailable)\n     * Resize info is available on Capacitor 4+\n     */\n    const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.a.None);\n    /**\n     * This tracks whether or not the keyboard has been\n     * presented for a single focused text field. Note\n     * that it does not track if the keyboard is open\n     * in general such as if the keyboard is open for\n     * a different focused text field.\n     */\n    let hasKeyboardBeenPresentedForTextField = false;\n    /**\n     * When adding scroll padding we need to know\n     * how much of the viewport the keyboard obscures.\n     * We do this by subtracting the keyboard height\n     * from the platform height.\n     *\n     * If we compute this value when switching between\n     * inputs then the webview may already be resized.\n     * At this point, `win.innerHeight` has already accounted\n     * for the keyboard meaning we would then subtract\n     * the keyboard height again. This will result in the input\n     * being scrolled more than it needs to.\n     */\n    const platformHeight = _index5_js__WEBPACK_IMPORTED_MODULE_2__.w !== undefined ? _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.innerHeight : 0;\n    /**\n     * Scroll assist is run when a text field\n     * is focused. However, it may need to\n     * re-run when the keyboard size changes\n     * such that the text field is now hidden\n     * underneath the keyboard.\n     * This function re-runs scroll assist\n     * when that happens.\n     *\n     * One limitation of this is on a web browser\n     * where native keyboard APIs do not have cross-browser\n     * support. `ionKeyboardDidShow` relies on the Visual Viewport API.\n     * This means that if the keyboard changes but does not change\n     * geometry, then scroll assist will not re-run even if\n     * the user has scrolled the text field under the keyboard.\n     * This is not a problem when running in Cordova/Capacitor\n     * because `ionKeyboardDidShow` uses the native events\n     * which fire every time the keyboard changes.\n     */\n    const keyboardShow = (ev) => {\n        /**\n         * If the keyboard has not yet been presented\n         * for this text field then the text field has just\n         * received focus. In that case, the focusin listener\n         * will run scroll assist.\n         */\n        if (hasKeyboardBeenPresentedForTextField === false) {\n            hasKeyboardBeenPresentedForTextField = true;\n            return;\n        }\n        /**\n         * Otherwise, the keyboard has already been presented\n         * for the focused text field.\n         * This means that the keyboard likely changed\n         * geometry, and we need to re-run scroll assist.\n         * This can happen when the user rotates their device\n         * or when they switch keyboards.\n         *\n         * Make sure we pass in the computed keyboard height\n         * rather than the estimated keyboard height.\n         *\n         * Since the keyboard is already open then we do not\n         * need to wait for the webview to resize, so we pass\n         * \"waitForResize: false\".\n         */\n        jsSetFocus(componentEl, inputEl, contentEl, footerEl, ev.detail.keyboardHeight, addScrollPadding, disableClonedInput, platformHeight, false);\n    };\n    /**\n     * Reset the internal state when the text field loses focus.\n     */\n    const focusOut = () => {\n        hasKeyboardBeenPresentedForTextField = false;\n        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);\n        componentEl.removeEventListener('focusout', focusOut);\n    };\n    /**\n     * When the input is about to receive\n     * focus, we need to move it to prevent\n     * mobile Safari from adjusting the viewport.\n     */\n    const focusIn = async () => {\n        /**\n         * Scroll assist should not run again\n         * on inputs that have been manually\n         * focused inside of the scroll assist\n         * implementation.\n         */\n        if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {\n            inputEl.removeAttribute(SKIP_SCROLL_ASSIST);\n            return;\n        }\n        jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput, platformHeight);\n        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.addEventListener('ionKeyboardDidShow', keyboardShow);\n        componentEl.addEventListener('focusout', focusOut);\n    };\n    componentEl.addEventListener('focusin', focusIn);\n    return () => {\n        componentEl.removeEventListener('focusin', focusIn);\n        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);\n        componentEl.removeEventListener('focusout', focusOut);\n    };\n};\n/**\n * Use this function when you want to manually\n * focus an input but not have scroll assist run again.\n */\nconst setManualFocus = (el) => {\n    /**\n     * If element is already focused then\n     * a new focusin event will not be dispatched\n     * to remove the SKIL_SCROLL_ASSIST attribute.\n     */\n    if (document.activeElement === el) {\n        return;\n    }\n    el.setAttribute(SKIP_SCROLL_ASSIST, 'true');\n    el.focus();\n};\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false, platformHeight = 0, waitForResize = true) => {\n    if (!contentEl && !footerEl) {\n        return;\n    }\n    const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight, platformHeight);\n    if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n        // the text input is in a safe position that doesn't\n        // require it to be scrolled into view, just set focus now\n        setManualFocus(inputEl);\n        /**\n         * Even though the input does not need\n         * scroll assist, we should preserve the\n         * the scroll padding as users could be moving\n         * focus from an input that needs scroll padding\n         * to an input that does not need scroll padding.\n         * If we remove the scroll padding now, users will\n         * see the page jump.\n         */\n        if (enableScrollPadding && contentEl !== null) {\n            setScrollPadding(contentEl, currentPadding);\n            setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));\n        }\n        return;\n    }\n    // temporarily move the focus to the focus holder so the browser\n    // doesn't freak out while it's trying to get the input in place\n    // at this point the native text input still does not have focus\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);\n    setManualFocus(inputEl);\n    /**\n     * Relocating/Focusing input causes the\n     * click event to be cancelled, so\n     * manually fire one here.\n     */\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => componentEl.click());\n    /**\n     * If enabled, we can add scroll padding to\n     * the bottom of the content so that scroll assist\n     * has enough room to scroll the input above\n     * the keyboard.\n     */\n    if (enableScrollPadding && contentEl) {\n        currentPadding = scrollData.scrollPadding;\n        setScrollPadding(contentEl, currentPadding);\n    }\n    if (typeof window !== 'undefined') {\n        let scrollContentTimeout;\n        const scrollContent = async () => {\n            // clean up listeners and timeouts\n            if (scrollContentTimeout !== undefined) {\n                clearTimeout(scrollContentTimeout);\n            }\n            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n            window.removeEventListener('ionKeyboardDidShow', scrollContent);\n            // scroll the input into place\n            if (contentEl) {\n                await (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);\n            }\n            // the scroll view is in the correct position now\n            // give the native text input focus\n            relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n            // ensure this is the focused input\n            setManualFocus(inputEl);\n            /**\n             * When the input is about to be blurred\n             * we should set a timeout to remove\n             * any scroll padding.\n             */\n            if (enableScrollPadding) {\n                setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));\n            }\n        };\n        const doubleKeyboardEventListener = () => {\n            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n            window.addEventListener('ionKeyboardDidShow', scrollContent);\n        };\n        if (contentEl) {\n            const scrollEl = await (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.g)(contentEl);\n            /**\n             * scrollData will only consider the amount we need\n             * to scroll in order to properly bring the input\n             * into view. It will not consider the amount\n             * we can scroll in the content element.\n             * As a result, scrollData may request a greater\n             * scroll position than is currently available\n             * in the DOM. If this is the case, we need to\n             * wait for the webview to resize/the keyboard\n             * to show in order for additional scroll\n             * bandwidth to become available.\n             */\n            const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n            if (waitForResize && scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {\n                /**\n                 * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n                 * after the initial keyboard is shown. This prevents the webview from resizing\n                 * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n                 */\n                if (inputEl.type === 'password') {\n                    // Add 50px to account for the \"Passwords\" bar\n                    scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;\n                    window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n                }\n                else {\n                    window.addEventListener('ionKeyboardDidShow', scrollContent);\n                }\n                /**\n                 * This should only fire in 2 instances:\n                 * 1. The app is very slow.\n                 * 2. The app is running in a browser on an old OS\n                 * that does not support Ionic Keyboard Events\n                 */\n                scrollContentTimeout = setTimeout(scrollContent, 1000);\n                return;\n            }\n        }\n        scrollContent();\n    }\n};\n\nconst INPUT_BLURRING = true;\nconst startInputShims = async (config, platform) => {\n    /**\n     * If doc is undefined then we are in an SSR environment\n     * where input shims do not apply.\n     */\n    if (_index5_js__WEBPACK_IMPORTED_MODULE_2__.d === undefined) {\n        return;\n    }\n    const isIOS = platform === 'ios';\n    const isAndroid = platform === 'android';\n    /**\n     * Hide Caret and Input Blurring are needed on iOS.\n     * Scroll Assist and Scroll Padding are needed on iOS and Android\n     * with Chrome web browser (not Chrome webview).\n     */\n    const keyboardHeight = config.getNumber('keyboardHeight', 290);\n    const scrollAssist = config.getBoolean('scrollAssist', true);\n    const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);\n    const inputBlurring = config.getBoolean('inputBlurring', isIOS);\n    const scrollPadding = config.getBoolean('scrollPadding', true);\n    const inputs = Array.from(_index5_js__WEBPACK_IMPORTED_MODULE_2__.d.querySelectorAll('ion-input, ion-textarea'));\n    const hideCaretMap = new WeakMap();\n    const scrollAssistMap = new WeakMap();\n    /**\n     * Grab the native keyboard resize configuration\n     * and pass it to scroll assist. Scroll assist requires\n     * that we adjust the input right before the input\n     * is about to be focused. If we called `Keyboard.getResizeMode`\n     * on focusin in scroll assist, we could potentially adjust the\n     * input too late since this call is async.\n     */\n    const keyboardResizeMode = await _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.K.getResizeMode();\n    const registerInput = async (componentEl) => {\n        await new Promise((resolve) => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.c)(componentEl, resolve));\n        const inputRoot = componentEl.shadowRoot || componentEl;\n        const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n        const scrollEl = (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.a)(componentEl);\n        const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;\n        if (!inputEl) {\n            return;\n        }\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n            hideCaretMap.set(componentEl, rmFn);\n        }\n        /**\n         * date/datetime-locale inputs on mobile devices show date picker\n         * overlays instead of keyboards. As a result, scroll assist is\n         * not needed. This also works around a bug in iOS <16 where\n         * scroll assist causes the browser to lock up. See FW-1997.\n         */\n        const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';\n        if (!isDateInput &&\n            (!!scrollEl || !!footerEl) &&\n            scrollAssist &&\n            !scrollAssistMap.has(componentEl)) {\n            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);\n            scrollAssistMap.set(componentEl, rmFn);\n        }\n    };\n    const unregisterInput = (componentEl) => {\n        if (hideCaret) {\n            const fn = hideCaretMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            hideCaretMap.delete(componentEl);\n        }\n        if (scrollAssist) {\n            const fn = scrollAssistMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            scrollAssistMap.delete(componentEl);\n        }\n    };\n    if (inputBlurring && INPUT_BLURRING) {\n        enableInputBlurring();\n    }\n    // Input might be already loaded in the DOM before ion-device-hacks did.\n    // At this point we need to look for all of the inputs not registered yet\n    // and register them.\n    for (const input of inputs) {\n        registerInput(input);\n    }\n    _index5_js__WEBPACK_IMPORTED_MODULE_2__.d.addEventListener('ionInputDidLoad', (ev) => {\n        registerInput(ev.detail);\n    });\n    _index5_js__WEBPACK_IMPORTED_MODULE_2__.d.addEventListener('ionInputDidUnload', (ev) => {\n        unregisterInput(ev.detail);\n    });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lucHV0LXNoaW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2lEO0FBQ21EO0FBQ1k7QUFDN0M7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRyxLQUFLLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOENBQWdCO0FBQ3BCLElBQUksOENBQWdCO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRLDhDQUFtQjtBQUMzQixRQUFRLDhDQUFtQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSSw4Q0FBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsMkNBQWM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUFHLGlCQUFpQix5Q0FBRztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQUcsYUFBYSx5Q0FBRyx1QkFBdUIseUNBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFHLGFBQWEseUNBQUcsdUJBQXVCLHlDQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFHLGFBQWEseUNBQUcsdUJBQXVCLHlDQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhDQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJDQUFRO0FBQzdDO0FBQ0EsdUNBQXVDLDhDQUFnQjtBQUN2RDtBQUNBO0FBQ0EseUJBQXlCLDZDQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlDQUFHO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsSUFBSSx5Q0FBRztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pbnB1dC1zaGltcy5qcz80NzkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyB3IGFzIHdpbiwgZCBhcyBkb2MgfSBmcm9tICcuL2luZGV4NS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFNjcm9sbEVsZW1lbnQsIGMgYXMgc2Nyb2xsQnlQb2ludCwgYSBhcyBmaW5kQ2xvc2VzdElvbkNvbnRlbnQgfSBmcm9tICcuL2luZGV4OC5qcyc7XG5pbXBvcnQgeyBhIGFzIGFkZEV2ZW50TGlzdGVuZXIsIGIgYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgciBhcyByYWYsIGMgYXMgY29tcG9uZW50T25SZWFkeSB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBhIGFzIEtleWJvYXJkUmVzaXplLCBLIGFzIEtleWJvYXJkIH0gZnJvbSAnLi9rZXlib2FyZC5qcyc7XG5cbmNvbnN0IGNsb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlbG9jYXRlSW5wdXQgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNob3VsZFJlbG9jYXRlLCBpbnB1dFJlbGF0aXZlWSA9IDAsIGRpc2FibGVkQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICAgIGlmIChjbG9uZU1hcC5oYXMoY29tcG9uZW50RWwpID09PSBzaG91bGRSZWxvY2F0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaG91bGRSZWxvY2F0ZSkge1xuICAgICAgICBhZGRDbG9uZShjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVksIGRpc2FibGVkQ2xvbmVkSW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2xvbmUoY29tcG9uZW50RWwsIGlucHV0RWwpO1xuICAgIH1cbn07XG5jb25zdCBpc0ZvY3VzZWQgPSAoaW5wdXQpID0+IHtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9nZXRSb290Tm9kZVxuICAgICAqIENhbGxpbmcgZ2V0Um9vdE5vZGUgb24gYW4gZWxlbWVudCBpbiBzdGFuZGFyZCB3ZWIgcGFnZSB3aWxsIHJldHVybiBIVE1MRG9jdW1lbnQuXG4gICAgICogQ2FsbGluZyBnZXRSb290Tm9kZSBvbiBhbiBlbGVtZW50IGluc2lkZSBvZiB0aGUgU2hhZG93IERPTSB3aWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBTaGFkb3dSb290LlxuICAgICAqIENhbGxpbmcgZ2V0Um9vdE5vZGUgb24gYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBhdHRhY2hlZCB0byBhIGRvY3VtZW50L3NoYWRvdyB0cmVlIHdpbGwgcmV0dXJuXG4gICAgICogdGhlIHJvb3Qgb2YgdGhlIERPTSB0cmVlIGl0IGJlbG9uZ3MgdG8uXG4gICAgICogaXNGb2N1c2VkIGlzIHVzZWQgZm9yIHRoZSBoaWRlLWNhcmV0IHV0aWxpdHkgd2hpY2ggb25seSBjb25zaWRlcnMgaW5wdXQvdGV4dGFyZWEgZWxlbWVudHNcbiAgICAgKiB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBET00sIHNvIHdlIGRvbid0IHNldCB0eXBlcyBmb3IgdGhhdCBmaW5hbCBjYXNlIHNpbmNlIGl0IGRvZXMgbm90IGFwcGx5LlxuICAgICAqL1xuICAgIHJldHVybiBpbnB1dCA9PT0gaW5wdXQuZ2V0Um9vdE5vZGUoKS5hY3RpdmVFbGVtZW50O1xufTtcbmNvbnN0IGFkZENsb25lID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBpbnB1dFJlbGF0aXZlWSwgZGlzYWJsZWRDbG9uZWRJbnB1dCA9IGZhbHNlKSA9PiB7XG4gICAgLy8gdGhpcyBhbGxvd3MgZm9yIHRoZSBhY3R1YWwgaW5wdXQgdG8gcmVjZWl2ZSB0aGUgZm9jdXMgZnJvbVxuICAgIC8vIHRoZSB1c2VyJ3MgdG91Y2ggZXZlbnQsIGJ1dCBiZWZvcmUgaXQgcmVjZWl2ZXMgZm9jdXMsIGl0XG4gICAgLy8gbW92ZXMgdGhlIGFjdHVhbCBpbnB1dCB0byBhIGxvY2F0aW9uIHRoYXQgd2lsbCBub3Qgc2NyZXdcbiAgICAvLyB1cCB0aGUgYXBwJ3MgbGF5b3V0LCBhbmQgZG9lcyBub3QgYWxsb3cgdGhlIG5hdGl2ZSBicm93c2VyXG4gICAgLy8gdG8gYXR0ZW1wdCB0byBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2UgKG1lc3NpbmcgdXAgaGVhZGVycy9mb290ZXJzKVxuICAgIC8vIHRoZSBjbG9uZWQgaW5wdXQgZmlsbHMgdGhlIGFyZWEgb2Ygd2hlcmUgbmF0aXZlIGlucHV0IHNob3VsZCBiZVxuICAgIC8vIHdoaWxlIHRoZSBuYXRpdmUgaW5wdXQgZmFrZXMgb3V0IHRoZSBicm93c2VyIGJ5IHJlbG9jYXRpbmcgaXRzZWxmXG4gICAgLy8gYmVmb3JlIGl0IHJlY2VpdmVzIHRoZSBhY3R1YWwgZm9jdXMgZXZlbnRcbiAgICAvLyBXZSBoaWRlIHRoZSBmb2N1c2VkIGlucHV0ICh3aXRoIHRoZSB2aXNpYmxlIGNhcmV0KSBpbnZpc2libGUgYnkgbWFraW5nIGl0IHNjYWxlKDApLFxuICAgIGNvbnN0IHBhcmVudEVsID0gaW5wdXRFbC5wYXJlbnROb2RlO1xuICAgIC8vIERPTSBXUklURVNcbiAgICBjb25zdCBjbG9uZWRFbCA9IGlucHV0RWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICBjbG9uZWRFbC5jbGFzc0xpc3QuYWRkKCdjbG9uZWQtaW5wdXQnKTtcbiAgICBjbG9uZWRFbC50YWJJbmRleCA9IC0xO1xuICAgIC8qKlxuICAgICAqIE1ha2luZyB0aGUgY2xvbmVkIGlucHV0IGRpc2FibGVkIHByZXZlbnRzXG4gICAgICogQ2hyb21lIGZvciBBbmRyb2lkIGZyb20gc3RpbGwgc2Nyb2xsaW5nXG4gICAgICogdGhlIGVudGlyZSBwYWdlIHNpbmNlIHRoaXMgY2xvbmVkIGlucHV0XG4gICAgICogd2lsbCBicmllZmx5IGJlIGhpZGRlbiBieSB0aGUga2V5Ym9hcmRcbiAgICAgKiBldmVuIHRob3VnaCBpdCBpcyBub3QgZm9jdXNlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IG5lZWRlZCBvbiBpT1MuIFdoaWxlIHRoaXNcbiAgICAgKiBkb2VzIG5vdCBjYXVzZSBmdW5jdGlvbmFsIGlzc3VlcyBvbiBpT1MsXG4gICAgICogdGhlIGlucHV0IHN0aWxsIGFwcGVhcnMgc2xpZ2h0bHkgZGltbWVkIGV2ZW5cbiAgICAgKiBpZiB3ZSBzZXQgb3BhY2l0eTogMS5cbiAgICAgKi9cbiAgICBpZiAoZGlzYWJsZWRDbG9uZWRJbnB1dCkge1xuICAgICAgICBjbG9uZWRFbC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNsb25lZEVsKTtcbiAgICBjbG9uZU1hcC5zZXQoY29tcG9uZW50RWwsIGNsb25lZEVsKTtcbiAgICBjb25zdCBkb2MgPSBjb21wb25lbnRFbC5vd25lckRvY3VtZW50O1xuICAgIGNvbnN0IHR4ID0gZG9jLmRpciA9PT0gJ3J0bCcgPyA5OTk5IDogLTk5OTk7XG4gICAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3R4fXB4LCR7aW5wdXRSZWxhdGl2ZVl9cHgsMCkgc2NhbGUoMClgO1xufTtcbmNvbnN0IHJlbW92ZUNsb25lID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsKSA9PiB7XG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZU1hcC5nZXQoY29tcG9uZW50RWwpO1xuICAgIGlmIChjbG9uZSkge1xuICAgICAgICBjbG9uZU1hcC5kZWxldGUoY29tcG9uZW50RWwpO1xuICAgICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgIGlucHV0RWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG59O1xuLyoqXG4gKiBGYWN0b3JpbmcgaW4gNTBweCBnaXZlcyB1cyBzb21lIHJvb21cbiAqIGluIGNhc2UgdGhlIGtleWJvYXJkIHNob3dzIHBhc3N3b3JkL2F1dG9maWxsIGJhcnNcbiAqIGFzeW5jaHJvbm91c2x5LlxuICovXG5jb25zdCBTQ1JPTExfQU1PVU5UX1BBRERJTkcgPSA1MDtcblxuY29uc3QgZW5hYmxlSGlkZUNhcmV0T25TY3JvbGwgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsKSA9PiB7XG4gICAgaWYgKCFzY3JvbGxFbCB8fCAhaW5wdXRFbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxIaWRlQ2FyZXQgPSAoc2hvdWxkSGlkZUNhcmV0KSA9PiB7XG4gICAgICAgIGlmIChpc0ZvY3VzZWQoaW5wdXRFbCkpIHtcbiAgICAgICAgICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIHNob3VsZEhpZGVDYXJldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uQmx1ciA9ICgpID0+IHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlKTtcbiAgICBjb25zdCBoaWRlQ2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQodHJ1ZSk7XG4gICAgY29uc3Qgc2hvd0NhcmV0ID0gKCkgPT4gc2Nyb2xsSGlkZUNhcmV0KGZhbHNlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsU3RhcnQnLCBoaWRlQ2FyZXQpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xuICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbEVuZCcsIHNob3dDYXJldCk7XG4gICAgICAgIGlucHV0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgfTtcbn07XG5cbmNvbnN0IFNLSVBfU0VMRUNUT1IgPSAnaW5wdXQsIHRleHRhcmVhLCBbbm8tYmx1cl0sIFtjb250ZW50ZWRpdGFibGVdJztcbmNvbnN0IGVuYWJsZUlucHV0Qmx1cnJpbmcgPSAoKSA9PiB7XG4gICAgbGV0IGZvY3VzZWQgPSB0cnVlO1xuICAgIGxldCBkaWRTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgZGlkU2Nyb2xsID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRm9jdXNpbiA9ICgpID0+IHtcbiAgICAgICAgZm9jdXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBvblRvdWNoZW5kID0gKGV2KSA9PiB7XG4gICAgICAgIC8vIGlmIGFwcCBkaWQgc2Nyb2xsIHJldHVybiBlYXJseVxuICAgICAgICBpZiAoZGlkU2Nyb2xsKSB7XG4gICAgICAgICAgICBkaWRTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IGJsdXIgaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGEgdGV4dC1pbnB1dCBvciBhIHRleHRhcmVhXG4gICAgICAgIGlmIChhY3RpdmUubWF0Y2hlcyhTS0lQX1NFTEVDVE9SKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzZWxlY3RlZCB0YXJnZXQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LCBkbyBub3QgYmx1clxuICAgICAgICBjb25zdCB0YXBwZWQgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmICh0YXBwZWQgPT09IGFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXBwZWQubWF0Y2hlcyhTS0lQX1NFTEVDVE9SKSB8fCB0YXBwZWQuY2xvc2VzdChTS0lQX1NFTEVDVE9SKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETyBGVy0yNzk2OiBmaW5kIGEgYmV0dGVyIHdheSwgd2h5IDUwbXM/XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApO1xuICAgIH07XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihkb2MsICdpb25TY3JvbGxTdGFydCcsIG9uU2Nyb2xsKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCwgZmFsc2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luLCB0cnVlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCwgZmFsc2UpO1xuICAgIH07XG59O1xuXG5jb25zdCBTQ1JPTExfQVNTSVNUX1NQRUVEID0gMC4zO1xuY29uc3QgZ2V0U2Nyb2xsRGF0YSA9IChjb21wb25lbnRFbCwgY29udGVudEVsLCBrZXlib2FyZEhlaWdodCwgcGxhdGZvcm1IZWlnaHQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaXRlbUVsID0gKF9hID0gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWl0ZW0sW2lvbi1pdGVtXScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21wb25lbnRFbDtcbiAgICByZXR1cm4gY2FsY1Njcm9sbERhdGEoaXRlbUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBjb250ZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCk7XG59O1xuY29uc3QgY2FsY1Njcm9sbERhdGEgPSAoaW5wdXRSZWN0LCBjb250ZW50UmVjdCwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KSA9PiB7XG4gICAgLy8gY29tcHV0ZSBpbnB1dCdzIFkgdmFsdWVzIHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgY29uc3QgaW5wdXRUb3AgPSBpbnB1dFJlY3QudG9wO1xuICAgIGNvbnN0IGlucHV0Qm90dG9tID0gaW5wdXRSZWN0LmJvdHRvbTtcbiAgICAvLyBjb21wdXRlIHZpc2libGUgYXJlYVxuICAgIGNvbnN0IHZpc2libGVBcmVhVG9wID0gY29udGVudFJlY3QudG9wO1xuICAgIGNvbnN0IHZpc2libGVBcmVhQm90dG9tID0gTWF0aC5taW4oY29udGVudFJlY3QuYm90dG9tLCBwbGF0Zm9ybUhlaWdodCAtIGtleWJvYXJkSGVpZ2h0KTtcbiAgICAvLyBjb21wdXRlIHNhZmUgYXJlYVxuICAgIGNvbnN0IHNhZmVBcmVhVG9wID0gdmlzaWJsZUFyZWFUb3AgKyAxNTtcbiAgICBjb25zdCBzYWZlQXJlYUJvdHRvbSA9IHZpc2libGVBcmVhQm90dG9tIC0gU0NST0xMX0FNT1VOVF9QQURESU5HO1xuICAgIC8vIGZpZ3VyZSBvdXQgaWYgZWFjaCBlZGdlIG9mIHRoZSBpbnB1dCBpcyB3aXRoaW4gdGhlIHNhZmUgYXJlYVxuICAgIGNvbnN0IGRpc3RhbmNlVG9Cb3R0b20gPSBzYWZlQXJlYUJvdHRvbSAtIGlucHV0Qm90dG9tO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9Ub3AgPSBzYWZlQXJlYVRvcCAtIGlucHV0VG9wO1xuICAgIC8vIGRlc2lyZWRTY3JvbGxBbW91bnQgaXMgdGhlIG5lZ2F0ZWQgZGlzdGFuY2UgdG8gdGhlIHNhZmUgYXJlYSBhY2NvcmRpbmcgdG8gb3VyIGNhbGN1bGF0aW9ucy5cbiAgICBjb25zdCBkZXNpcmVkU2Nyb2xsQW1vdW50ID0gTWF0aC5yb3VuZChkaXN0YW5jZVRvQm90dG9tIDwgMCA/IC1kaXN0YW5jZVRvQm90dG9tIDogZGlzdGFuY2VUb1RvcCA+IDAgPyAtZGlzdGFuY2VUb1RvcCA6IDApO1xuICAgIC8vIG91ciBjYWxjdWxhdGlvbnMgbWFrZSBzb21lIGFzc3VtcHRpb25zIHRoYXQgYXJlbid0IGFsd2F5cyB0cnVlLCBsaWtlIHRoZSBrZXlib2FyZCBiZWluZyBjbG9zZWQgd2hlbiBhbiBpbnB1dFxuICAgIC8vIGdldHMgZm9jdXMsIHNvIG1ha2Ugc3VyZSB3ZSBkb24ndCBzY3JvbGwgdGhlIGlucHV0IGFib3ZlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCBzY3JvbGxBbW91bnQgPSBNYXRoLm1pbihkZXNpcmVkU2Nyb2xsQW1vdW50LCBpbnB1dFRvcCAtIHZpc2libGVBcmVhVG9wKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKHNjcm9sbEFtb3VudCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBkaXN0YW5jZSAvIFNDUk9MTF9BU1NJU1RfU1BFRUQ7XG4gICAgY29uc3Qgc2Nyb2xsRHVyYXRpb24gPSBNYXRoLm1pbig0MDAsIE1hdGgubWF4KDE1MCwgZHVyYXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JvbGxBbW91bnQsXG4gICAgICAgIHNjcm9sbER1cmF0aW9uLFxuICAgICAgICBzY3JvbGxQYWRkaW5nOiBrZXlib2FyZEhlaWdodCxcbiAgICAgICAgaW5wdXRTYWZlWTogLShpbnB1dFRvcCAtIHNhZmVBcmVhVG9wKSArIDQsXG4gICAgfTtcbn07XG5cbmNvbnN0IFBBRERJTkdfVElNRVJfS0VZID0gJyRpb25QYWRkaW5nVGltZXInO1xuLyoqXG4gKiBTY3JvbGwgcGFkZGluZyBhZGRzIGFkZGl0aW9uYWwgcGFkZGluZyB0byB0aGUgYm90dG9tXG4gKiBvZiBpb24tY29udGVudCBzbyB0aGF0IHRoZXJlIGlzIGVub3VnaCBzY3JvbGwgc3BhY2VcbiAqIGZvciBhbiBpbnB1dCB0byBiZSBzY3JvbGxlZCBhYm92ZSB0aGUga2V5Ym9hcmQuIFRoaXNcbiAqIGlzIG5lZWRlZCBpbiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIHdlYnZpZXcgZG9lcyBub3RcbiAqIHJlc2l6ZSB3aGVuIHRoZSBrZXlib2FyZCBvcGVucy5cbiAqXG4gKiBFeGFtcGxlOiBJZiBhbiBpbnB1dCBhdCB0aGUgYm90dG9tIG9mIGlvbi1jb250ZW50IGlzXG4gKiBmb2N1c2VkLCB0aGVyZSBpcyBubyBhZGRpdGlvbmFsIHNjcm9sbGluZyBzcGFjZSBiZWxvd1xuICogaXQsIHNvIHRoZSBpbnB1dCBjYW5ub3QgYmUgc2Nyb2xsZWQgYWJvdmUgdGhlIGtleWJvYXJkLlxuICogU2Nyb2xsIHBhZGRpbmcgZml4ZXMgdGhpcyBieSBhZGRpbmcgcGFkZGluZyBlcXVhbCB0byB0aGVcbiAqIGhlaWdodCBvZiB0aGUga2V5Ym9hcmQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgY29udGVudC5cbiAqXG4gKiBDb21tb24gZW52aXJvbm1lbnRzIHdoZXJlIHRoaXMgaXMgbmVlZGVkOlxuICogLSBNb2JpbGUgU2FmYXJpOiBUaGUga2V5Ym9hcmQgb3ZlcmxheXMgdGhlIGNvbnRlbnRcbiAqIC0gQ2FwYWNpdG9yL0NvcmRvdmEgb24gaU9TOiBUaGUga2V5Ym9hcmQgb3ZlcmxheXMgdGhlIGNvbnRlbnRcbiAqIHdoZW4gdGhlIEtleWJvYXJkUmVzaXplIG1vZGUgaXMgc2V0IHRvICdub25lJy5cbiAqL1xuY29uc3Qgc2V0U2Nyb2xsUGFkZGluZyA9IChjb250ZW50RWwsIHBhZGRpbmdBbW91bnQsIGNsZWFyQ2FsbGJhY2spID0+IHtcbiAgICBjb25zdCB0aW1lciA9IGNvbnRlbnRFbFtQQURESU5HX1RJTUVSX0tFWV07XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIGlmIChwYWRkaW5nQW1vdW50ID4gMCkge1xuICAgICAgICBjb250ZW50RWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgYCR7cGFkZGluZ0Ftb3VudH1weGApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudEVsW1BBRERJTkdfVElNRVJfS0VZXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLnNldFByb3BlcnR5KCctLWtleWJvYXJkLW9mZnNldCcsICcwcHgnKTtcbiAgICAgICAgICAgIGlmIChjbGVhckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMjApO1xuICAgIH1cbn07XG4vKipcbiAqIFdoZW4gYW4gaW5wdXQgaXMgYWJvdXQgdG8gYmUgZm9jdXNlZCxcbiAqIHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgYW55IHNjcm9sbCBwYWRkaW5nXG4gKiBvbiB0aGUgY29udGVudC4gTm90ZTogVGhlIGNsZWFyaW5nXG4gKiBpcyBkb25lIG9uIGEgdGltZW91dCBzbyB0aGF0IGlmIHVzZXJzXG4gKiBhcmUgbW92aW5nIGZvY3VzIGZyb20gb25lIGlucHV0IHRvIHRoZSBuZXh0XG4gKiB0aGVuIHJlLWFkZGluZyBzY3JvbGwgcGFkZGluZyB0byB0aGUgbmV3XG4gKiBpbnB1dCB3aXRoIGNhbmNlbCB0aGUgdGltZW91dCB0byBjbGVhciB0aGVcbiAqIHNjcm9sbCBwYWRkaW5nLlxuICovXG5jb25zdCBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lciA9IChpbnB1dEVsLCBjb250ZW50RWwsIGRvbmVDYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IGNsZWFyU2Nyb2xsUGFkZGluZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIDAsIGRvbmVDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBjbGVhclNjcm9sbFBhZGRpbmcsIHsgb25jZTogdHJ1ZSB9KTtcbn07XG5cbmxldCBjdXJyZW50UGFkZGluZyA9IDA7XG5jb25zdCBTS0lQX1NDUk9MTF9BU1NJU1QgPSAnZGF0YS1pb25pYy1za2lwLXNjcm9sbC1hc3Npc3QnO1xuY29uc3QgZW5hYmxlU2Nyb2xsQXNzaXN0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgZW5hYmxlU2Nyb2xsUGFkZGluZywga2V5Ym9hcmRSZXNpemUsIGRpc2FibGVDbG9uZWRJbnB1dCA9IGZhbHNlKSA9PiB7XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHBhZGRpbmcgc2hvdWxkIG9ubHkgYmUgYWRkZWQgaWY6XG4gICAgICogMS4gVGhlIGdsb2JhbCBzY3JvbGxQYWRkaW5nIGNvbmZpZyBvcHRpb25cbiAgICAgKiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiAyLiBUaGUgbmF0aXZlIGtleWJvYXJkIHJlc2l6ZSBtb2RlIGlzIGVpdGhlciBcIm5vbmVcIlxuICAgICAqIChrZXlib2FyZCBvdmVybGF5cyB3ZWJ2aWV3KSBvciB1bmRlZmluZWQgKHJlc2l6ZVxuICAgICAqIGluZm9ybWF0aW9uIHVuYXZhaWxhYmxlKVxuICAgICAqIFJlc2l6ZSBpbmZvIGlzIGF2YWlsYWJsZSBvbiBDYXBhY2l0b3IgNCtcbiAgICAgKi9cbiAgICBjb25zdCBhZGRTY3JvbGxQYWRkaW5nID0gZW5hYmxlU2Nyb2xsUGFkZGluZyAmJiAoa2V5Ym9hcmRSZXNpemUgPT09IHVuZGVmaW5lZCB8fCBrZXlib2FyZFJlc2l6ZS5tb2RlID09PSBLZXlib2FyZFJlc2l6ZS5Ob25lKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRyYWNrcyB3aGV0aGVyIG9yIG5vdCB0aGUga2V5Ym9hcmQgaGFzIGJlZW5cbiAgICAgKiBwcmVzZW50ZWQgZm9yIGEgc2luZ2xlIGZvY3VzZWQgdGV4dCBmaWVsZC4gTm90ZVxuICAgICAqIHRoYXQgaXQgZG9lcyBub3QgdHJhY2sgaWYgdGhlIGtleWJvYXJkIGlzIG9wZW5cbiAgICAgKiBpbiBnZW5lcmFsIHN1Y2ggYXMgaWYgdGhlIGtleWJvYXJkIGlzIG9wZW4gZm9yXG4gICAgICogYSBkaWZmZXJlbnQgZm9jdXNlZCB0ZXh0IGZpZWxkLlxuICAgICAqL1xuICAgIGxldCBoYXNLZXlib2FyZEJlZW5QcmVzZW50ZWRGb3JUZXh0RmllbGQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGFkZGluZyBzY3JvbGwgcGFkZGluZyB3ZSBuZWVkIHRvIGtub3dcbiAgICAgKiBob3cgbXVjaCBvZiB0aGUgdmlld3BvcnQgdGhlIGtleWJvYXJkIG9ic2N1cmVzLlxuICAgICAqIFdlIGRvIHRoaXMgYnkgc3VidHJhY3RpbmcgdGhlIGtleWJvYXJkIGhlaWdodFxuICAgICAqIGZyb20gdGhlIHBsYXRmb3JtIGhlaWdodC5cbiAgICAgKlxuICAgICAqIElmIHdlIGNvbXB1dGUgdGhpcyB2YWx1ZSB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuXG4gICAgICogaW5wdXRzIHRoZW4gdGhlIHdlYnZpZXcgbWF5IGFscmVhZHkgYmUgcmVzaXplZC5cbiAgICAgKiBBdCB0aGlzIHBvaW50LCBgd2luLmlubmVySGVpZ2h0YCBoYXMgYWxyZWFkeSBhY2NvdW50ZWRcbiAgICAgKiBmb3IgdGhlIGtleWJvYXJkIG1lYW5pbmcgd2Ugd291bGQgdGhlbiBzdWJ0cmFjdFxuICAgICAqIHRoZSBrZXlib2FyZCBoZWlnaHQgYWdhaW4uIFRoaXMgd2lsbCByZXN1bHQgaW4gdGhlIGlucHV0XG4gICAgICogYmVpbmcgc2Nyb2xsZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvLlxuICAgICAqL1xuICAgIGNvbnN0IHBsYXRmb3JtSGVpZ2h0ID0gd2luICE9PSB1bmRlZmluZWQgPyB3aW4uaW5uZXJIZWlnaHQgOiAwO1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCBhc3Npc3QgaXMgcnVuIHdoZW4gYSB0ZXh0IGZpZWxkXG4gICAgICogaXMgZm9jdXNlZC4gSG93ZXZlciwgaXQgbWF5IG5lZWQgdG9cbiAgICAgKiByZS1ydW4gd2hlbiB0aGUga2V5Ym9hcmQgc2l6ZSBjaGFuZ2VzXG4gICAgICogc3VjaCB0aGF0IHRoZSB0ZXh0IGZpZWxkIGlzIG5vdyBoaWRkZW5cbiAgICAgKiB1bmRlcm5lYXRoIHRoZSBrZXlib2FyZC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlLXJ1bnMgc2Nyb2xsIGFzc2lzdFxuICAgICAqIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgICAqXG4gICAgICogT25lIGxpbWl0YXRpb24gb2YgdGhpcyBpcyBvbiBhIHdlYiBicm93c2VyXG4gICAgICogd2hlcmUgbmF0aXZlIGtleWJvYXJkIEFQSXMgZG8gbm90IGhhdmUgY3Jvc3MtYnJvd3NlclxuICAgICAqIHN1cHBvcnQuIGBpb25LZXlib2FyZERpZFNob3dgIHJlbGllcyBvbiB0aGUgVmlzdWFsIFZpZXdwb3J0IEFQSS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIGtleWJvYXJkIGNoYW5nZXMgYnV0IGRvZXMgbm90IGNoYW5nZVxuICAgICAqIGdlb21ldHJ5LCB0aGVuIHNjcm9sbCBhc3Npc3Qgd2lsbCBub3QgcmUtcnVuIGV2ZW4gaWZcbiAgICAgKiB0aGUgdXNlciBoYXMgc2Nyb2xsZWQgdGhlIHRleHQgZmllbGQgdW5kZXIgdGhlIGtleWJvYXJkLlxuICAgICAqIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aGVuIHJ1bm5pbmcgaW4gQ29yZG92YS9DYXBhY2l0b3JcbiAgICAgKiBiZWNhdXNlIGBpb25LZXlib2FyZERpZFNob3dgIHVzZXMgdGhlIG5hdGl2ZSBldmVudHNcbiAgICAgKiB3aGljaCBmaXJlIGV2ZXJ5IHRpbWUgdGhlIGtleWJvYXJkIGNoYW5nZXMuXG4gICAgICovXG4gICAgY29uc3Qga2V5Ym9hcmRTaG93ID0gKGV2KSA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUga2V5Ym9hcmQgaGFzIG5vdCB5ZXQgYmVlbiBwcmVzZW50ZWRcbiAgICAgICAgICogZm9yIHRoaXMgdGV4dCBmaWVsZCB0aGVuIHRoZSB0ZXh0IGZpZWxkIGhhcyBqdXN0XG4gICAgICAgICAqIHJlY2VpdmVkIGZvY3VzLiBJbiB0aGF0IGNhc2UsIHRoZSBmb2N1c2luIGxpc3RlbmVyXG4gICAgICAgICAqIHdpbGwgcnVuIHNjcm9sbCBhc3Npc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUga2V5Ym9hcmQgaGFzIGFscmVhZHkgYmVlbiBwcmVzZW50ZWRcbiAgICAgICAgICogZm9yIHRoZSBmb2N1c2VkIHRleHQgZmllbGQuXG4gICAgICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUga2V5Ym9hcmQgbGlrZWx5IGNoYW5nZWRcbiAgICAgICAgICogZ2VvbWV0cnksIGFuZCB3ZSBuZWVkIHRvIHJlLXJ1biBzY3JvbGwgYXNzaXN0LlxuICAgICAgICAgKiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdXNlciByb3RhdGVzIHRoZWlyIGRldmljZVxuICAgICAgICAgKiBvciB3aGVuIHRoZXkgc3dpdGNoIGtleWJvYXJkcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTWFrZSBzdXJlIHdlIHBhc3MgaW4gdGhlIGNvbXB1dGVkIGtleWJvYXJkIGhlaWdodFxuICAgICAgICAgKiByYXRoZXIgdGhhbiB0aGUgZXN0aW1hdGVkIGtleWJvYXJkIGhlaWdodC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2luY2UgdGhlIGtleWJvYXJkIGlzIGFscmVhZHkgb3BlbiB0aGVuIHdlIGRvIG5vdFxuICAgICAgICAgKiBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3ZWJ2aWV3IHRvIHJlc2l6ZSwgc28gd2UgcGFzc1xuICAgICAgICAgKiBcIndhaXRGb3JSZXNpemU6IGZhbHNlXCIuXG4gICAgICAgICAqL1xuICAgICAgICBqc1NldEZvY3VzKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBldi5kZXRhaWwua2V5Ym9hcmRIZWlnaHQsIGFkZFNjcm9sbFBhZGRpbmcsIGRpc2FibGVDbG9uZWRJbnB1dCwgcGxhdGZvcm1IZWlnaHQsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZSB3aGVuIHRoZSB0ZXh0IGZpZWxkIGxvc2VzIGZvY3VzLlxuICAgICAqL1xuICAgIGNvbnN0IGZvY3VzT3V0ID0gKCkgPT4ge1xuICAgICAgICBoYXNLZXlib2FyZEJlZW5QcmVzZW50ZWRGb3JUZXh0RmllbGQgPSBmYWxzZTtcbiAgICAgICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGtleWJvYXJkU2hvdyk7XG4gICAgICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm9jdXNPdXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgaW5wdXQgaXMgYWJvdXQgdG8gcmVjZWl2ZVxuICAgICAqIGZvY3VzLCB3ZSBuZWVkIHRvIG1vdmUgaXQgdG8gcHJldmVudFxuICAgICAqIG1vYmlsZSBTYWZhcmkgZnJvbSBhZGp1c3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGNvbnN0IGZvY3VzSW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgYXNzaXN0IHNob3VsZCBub3QgcnVuIGFnYWluXG4gICAgICAgICAqIG9uIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBtYW51YWxseVxuICAgICAgICAgKiBmb2N1c2VkIGluc2lkZSBvZiB0aGUgc2Nyb2xsIGFzc2lzdFxuICAgICAgICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpbnB1dEVsLmhhc0F0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QpKSB7XG4gICAgICAgICAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGpzU2V0Rm9jdXMoY29tcG9uZW50RWwsIGlucHV0RWwsIGNvbnRlbnRFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0LCBhZGRTY3JvbGxQYWRkaW5nLCBkaXNhYmxlQ2xvbmVkSW5wdXQsIHBsYXRmb3JtSGVpZ2h0KTtcbiAgICAgICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGtleWJvYXJkU2hvdyk7XG4gICAgICAgIGNvbXBvbmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm9jdXNPdXQpO1xuICAgIH07XG4gICAgY29tcG9uZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZvY3VzSW4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmb2N1c0luKTtcbiAgICAgICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGtleWJvYXJkU2hvdyk7XG4gICAgICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm9jdXNPdXQpO1xuICAgIH07XG59O1xuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiB3aGVuIHlvdSB3YW50IHRvIG1hbnVhbGx5XG4gKiBmb2N1cyBhbiBpbnB1dCBidXQgbm90IGhhdmUgc2Nyb2xsIGFzc2lzdCBydW4gYWdhaW4uXG4gKi9cbmNvbnN0IHNldE1hbnVhbEZvY3VzID0gKGVsKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgdGhlblxuICAgICAqIGEgbmV3IGZvY3VzaW4gZXZlbnQgd2lsbCBub3QgYmUgZGlzcGF0Y2hlZFxuICAgICAqIHRvIHJlbW92ZSB0aGUgU0tJTF9TQ1JPTExfQVNTSVNUIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoU0tJUF9TQ1JPTExfQVNTSVNULCAndHJ1ZScpO1xuICAgIGVsLmZvY3VzKCk7XG59O1xuY29uc3QganNTZXRGb2N1cyA9IGFzeW5jIChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGVuYWJsZVNjcm9sbFBhZGRpbmcsIGRpc2FibGVDbG9uZWRJbnB1dCA9IGZhbHNlLCBwbGF0Zm9ybUhlaWdodCA9IDAsIHdhaXRGb3JSZXNpemUgPSB0cnVlKSA9PiB7XG4gICAgaWYgKCFjb250ZW50RWwgJiYgIWZvb3RlckVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsRGF0YSA9IGdldFNjcm9sbERhdGEoY29tcG9uZW50RWwsIChjb250ZW50RWwgfHwgZm9vdGVyRWwpLCBrZXlib2FyZEhlaWdodCwgcGxhdGZvcm1IZWlnaHQpO1xuICAgIGlmIChjb250ZW50RWwgJiYgTWF0aC5hYnMoc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQpIDwgNCkge1xuICAgICAgICAvLyB0aGUgdGV4dCBpbnB1dCBpcyBpbiBhIHNhZmUgcG9zaXRpb24gdGhhdCBkb2Vzbid0XG4gICAgICAgIC8vIHJlcXVpcmUgaXQgdG8gYmUgc2Nyb2xsZWQgaW50byB2aWV3LCBqdXN0IHNldCBmb2N1cyBub3dcbiAgICAgICAgc2V0TWFudWFsRm9jdXMoaW5wdXRFbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVuIHRob3VnaCB0aGUgaW5wdXQgZG9lcyBub3QgbmVlZFxuICAgICAgICAgKiBzY3JvbGwgYXNzaXN0LCB3ZSBzaG91bGQgcHJlc2VydmUgdGhlXG4gICAgICAgICAqIHRoZSBzY3JvbGwgcGFkZGluZyBhcyB1c2VycyBjb3VsZCBiZSBtb3ZpbmdcbiAgICAgICAgICogZm9jdXMgZnJvbSBhbiBpbnB1dCB0aGF0IG5lZWRzIHNjcm9sbCBwYWRkaW5nXG4gICAgICAgICAqIHRvIGFuIGlucHV0IHRoYXQgZG9lcyBub3QgbmVlZCBzY3JvbGwgcGFkZGluZy5cbiAgICAgICAgICogSWYgd2UgcmVtb3ZlIHRoZSBzY3JvbGwgcGFkZGluZyBub3csIHVzZXJzIHdpbGxcbiAgICAgICAgICogc2VlIHRoZSBwYWdlIGp1bXAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZW5hYmxlU2Nyb2xsUGFkZGluZyAmJiBjb250ZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbFBhZGRpbmcoY29udGVudEVsLCBjdXJyZW50UGFkZGluZyk7XG4gICAgICAgICAgICBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lcihpbnB1dEVsLCBjb250ZW50RWwsICgpID0+IChjdXJyZW50UGFkZGluZyA9IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRlbXBvcmFyaWx5IG1vdmUgdGhlIGZvY3VzIHRvIHRoZSBmb2N1cyBob2xkZXIgc28gdGhlIGJyb3dzZXJcbiAgICAvLyBkb2Vzbid0IGZyZWFrIG91dCB3aGlsZSBpdCdzIHRyeWluZyB0byBnZXQgdGhlIGlucHV0IGluIHBsYWNlXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgbmF0aXZlIHRleHQgaW5wdXQgc3RpbGwgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIHRydWUsIHNjcm9sbERhdGEuaW5wdXRTYWZlWSwgZGlzYWJsZUNsb25lZElucHV0KTtcbiAgICBzZXRNYW51YWxGb2N1cyhpbnB1dEVsKTtcbiAgICAvKipcbiAgICAgKiBSZWxvY2F0aW5nL0ZvY3VzaW5nIGlucHV0IGNhdXNlcyB0aGVcbiAgICAgKiBjbGljayBldmVudCB0byBiZSBjYW5jZWxsZWQsIHNvXG4gICAgICogbWFudWFsbHkgZmlyZSBvbmUgaGVyZS5cbiAgICAgKi9cbiAgICByYWYoKCkgPT4gY29tcG9uZW50RWwuY2xpY2soKSk7XG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlZCwgd2UgY2FuIGFkZCBzY3JvbGwgcGFkZGluZyB0b1xuICAgICAqIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQgc28gdGhhdCBzY3JvbGwgYXNzaXN0XG4gICAgICogaGFzIGVub3VnaCByb29tIHRvIHNjcm9sbCB0aGUgaW5wdXQgYWJvdmVcbiAgICAgKiB0aGUga2V5Ym9hcmQuXG4gICAgICovXG4gICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgY29udGVudEVsKSB7XG4gICAgICAgIGN1cnJlbnRQYWRkaW5nID0gc2Nyb2xsRGF0YS5zY3JvbGxQYWRkaW5nO1xuICAgICAgICBzZXRTY3JvbGxQYWRkaW5nKGNvbnRlbnRFbCwgY3VycmVudFBhZGRpbmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV0IHNjcm9sbENvbnRlbnRUaW1lb3V0O1xuICAgICAgICBjb25zdCBzY3JvbGxDb250ZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gY2xlYW4gdXAgbGlzdGVuZXJzIGFuZCB0aW1lb3V0c1xuICAgICAgICAgICAgaWYgKHNjcm9sbENvbnRlbnRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsQ29udGVudFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XG4gICAgICAgICAgICAvLyBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2VcbiAgICAgICAgICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzY3JvbGxCeVBvaW50KGNvbnRlbnRFbCwgMCwgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQsIHNjcm9sbERhdGEuc2Nyb2xsRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIHNjcm9sbCB2aWV3IGlzIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIG5vd1xuICAgICAgICAgICAgLy8gZ2l2ZSB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZm9jdXNcbiAgICAgICAgICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlLCBzY3JvbGxEYXRhLmlucHV0U2FmZVkpO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoaXMgaXMgdGhlIGZvY3VzZWQgaW5wdXRcbiAgICAgICAgICAgIHNldE1hbnVhbEZvY3VzKGlucHV0RWwpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBpbnB1dCBpcyBhYm91dCB0byBiZSBibHVycmVkXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgc2V0IGEgdGltZW91dCB0byByZW1vdmVcbiAgICAgICAgICAgICAqIGFueSBzY3JvbGwgcGFkZGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lcihpbnB1dEVsLCBjb250ZW50RWwsICgpID0+IChjdXJyZW50UGFkZGluZyA9IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgZ2V0U2Nyb2xsRWxlbWVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzY3JvbGxEYXRhIHdpbGwgb25seSBjb25zaWRlciB0aGUgYW1vdW50IHdlIG5lZWRcbiAgICAgICAgICAgICAqIHRvIHNjcm9sbCBpbiBvcmRlciB0byBwcm9wZXJseSBicmluZyB0aGUgaW5wdXRcbiAgICAgICAgICAgICAqIGludG8gdmlldy4gSXQgd2lsbCBub3QgY29uc2lkZXIgdGhlIGFtb3VudFxuICAgICAgICAgICAgICogd2UgY2FuIHNjcm9sbCBpbiB0aGUgY29udGVudCBlbGVtZW50LlxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQsIHNjcm9sbERhdGEgbWF5IHJlcXVlc3QgYSBncmVhdGVyXG4gICAgICAgICAgICAgKiBzY3JvbGwgcG9zaXRpb24gdGhhbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlXG4gICAgICAgICAgICAgKiBpbiB0aGUgRE9NLiBJZiB0aGlzIGlzIHRoZSBjYXNlLCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgKiB3YWl0IGZvciB0aGUgd2VidmlldyB0byByZXNpemUvdGhlIGtleWJvYXJkXG4gICAgICAgICAgICAgKiB0byBzaG93IGluIG9yZGVyIGZvciBhZGRpdGlvbmFsIHNjcm9sbFxuICAgICAgICAgICAgICogYmFuZHdpZHRoIHRvIGJlY29tZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsQW1vdW50ID0gc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHdhaXRGb3JSZXNpemUgJiYgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQgPiB0b3RhbFNjcm9sbEFtb3VudCAtIHNjcm9sbEVsLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9uIGlPUyBkZXZpY2VzLCB0aGUgc3lzdGVtIHdpbGwgc2hvdyBhIFwiUGFzc3dvcmRzXCIgYmFyIGFib3ZlIHRoZSBrZXlib2FyZFxuICAgICAgICAgICAgICAgICAqIGFmdGVyIHRoZSBpbml0aWFsIGtleWJvYXJkIGlzIHNob3duLiBUaGlzIHByZXZlbnRzIHRoZSB3ZWJ2aWV3IGZyb20gcmVzaXppbmdcbiAgICAgICAgICAgICAgICAgKiB1bnRpbCB0aGUgXCJQYXNzd29yZHNcIiBiYXIgaXMgc2hvd24sIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhhdCB0byBoYXBwZW4gZmlyc3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0RWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgNTBweCB0byBhY2NvdW50IGZvciB0aGUgXCJQYXNzd29yZHNcIiBiYXJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQgKz0gU0NST0xMX0FNT1VOVF9QQURESU5HO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBzaG91bGQgb25seSBmaXJlIGluIDIgaW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAqIDEuIFRoZSBhcHAgaXMgdmVyeSBzbG93LlxuICAgICAgICAgICAgICAgICAqIDIuIFRoZSBhcHAgaXMgcnVubmluZyBpbiBhIGJyb3dzZXIgb24gYW4gb2xkIE9TXG4gICAgICAgICAgICAgICAgICogdGhhdCBkb2VzIG5vdCBzdXBwb3J0IElvbmljIEtleWJvYXJkIEV2ZW50c1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNjcm9sbENvbnRlbnRUaW1lb3V0ID0gc2V0VGltZW91dChzY3JvbGxDb250ZW50LCAxMDAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Nyb2xsQ29udGVudCgpO1xuICAgIH1cbn07XG5cbmNvbnN0IElOUFVUX0JMVVJSSU5HID0gdHJ1ZTtcbmNvbnN0IHN0YXJ0SW5wdXRTaGltcyA9IGFzeW5jIChjb25maWcsIHBsYXRmb3JtKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgZG9jIGlzIHVuZGVmaW5lZCB0aGVuIHdlIGFyZSBpbiBhbiBTU1IgZW52aXJvbm1lbnRcbiAgICAgKiB3aGVyZSBpbnB1dCBzaGltcyBkbyBub3QgYXBwbHkuXG4gICAgICovXG4gICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNJT1MgPSBwbGF0Zm9ybSA9PT0gJ2lvcyc7XG4gICAgY29uc3QgaXNBbmRyb2lkID0gcGxhdGZvcm0gPT09ICdhbmRyb2lkJztcbiAgICAvKipcbiAgICAgKiBIaWRlIENhcmV0IGFuZCBJbnB1dCBCbHVycmluZyBhcmUgbmVlZGVkIG9uIGlPUy5cbiAgICAgKiBTY3JvbGwgQXNzaXN0IGFuZCBTY3JvbGwgUGFkZGluZyBhcmUgbmVlZGVkIG9uIGlPUyBhbmQgQW5kcm9pZFxuICAgICAqIHdpdGggQ2hyb21lIHdlYiBicm93c2VyIChub3QgQ2hyb21lIHdlYnZpZXcpLlxuICAgICAqL1xuICAgIGNvbnN0IGtleWJvYXJkSGVpZ2h0ID0gY29uZmlnLmdldE51bWJlcigna2V5Ym9hcmRIZWlnaHQnLCAyOTApO1xuICAgIGNvbnN0IHNjcm9sbEFzc2lzdCA9IGNvbmZpZy5nZXRCb29sZWFuKCdzY3JvbGxBc3Npc3QnLCB0cnVlKTtcbiAgICBjb25zdCBoaWRlQ2FyZXQgPSBjb25maWcuZ2V0Qm9vbGVhbignaGlkZUNhcmV0T25TY3JvbGwnLCBpc0lPUyk7XG4gICAgY29uc3QgaW5wdXRCbHVycmluZyA9IGNvbmZpZy5nZXRCb29sZWFuKCdpbnB1dEJsdXJyaW5nJywgaXNJT1MpO1xuICAgIGNvbnN0IHNjcm9sbFBhZGRpbmcgPSBjb25maWcuZ2V0Qm9vbGVhbignc2Nyb2xsUGFkZGluZycsIHRydWUpO1xuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1pbnB1dCwgaW9uLXRleHRhcmVhJykpO1xuICAgIGNvbnN0IGhpZGVDYXJldE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3Qgc2Nyb2xsQXNzaXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKipcbiAgICAgKiBHcmFiIHRoZSBuYXRpdmUga2V5Ym9hcmQgcmVzaXplIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBhbmQgcGFzcyBpdCB0byBzY3JvbGwgYXNzaXN0LiBTY3JvbGwgYXNzaXN0IHJlcXVpcmVzXG4gICAgICogdGhhdCB3ZSBhZGp1c3QgdGhlIGlucHV0IHJpZ2h0IGJlZm9yZSB0aGUgaW5wdXRcbiAgICAgKiBpcyBhYm91dCB0byBiZSBmb2N1c2VkLiBJZiB3ZSBjYWxsZWQgYEtleWJvYXJkLmdldFJlc2l6ZU1vZGVgXG4gICAgICogb24gZm9jdXNpbiBpbiBzY3JvbGwgYXNzaXN0LCB3ZSBjb3VsZCBwb3RlbnRpYWxseSBhZGp1c3QgdGhlXG4gICAgICogaW5wdXQgdG9vIGxhdGUgc2luY2UgdGhpcyBjYWxsIGlzIGFzeW5jLlxuICAgICAqL1xuICAgIGNvbnN0IGtleWJvYXJkUmVzaXplTW9kZSA9IGF3YWl0IEtleWJvYXJkLmdldFJlc2l6ZU1vZGUoKTtcbiAgICBjb25zdCByZWdpc3RlcklucHV0ID0gYXN5bmMgKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBjb21wb25lbnRPblJlYWR5KGNvbXBvbmVudEVsLCByZXNvbHZlKSk7XG4gICAgICAgIGNvbnN0IGlucHV0Um9vdCA9IGNvbXBvbmVudEVsLnNoYWRvd1Jvb3QgfHwgY29tcG9uZW50RWw7XG4gICAgICAgIGNvbnN0IGlucHV0RWwgPSBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcignaW5wdXQnKSB8fCBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBmaW5kQ2xvc2VzdElvbkNvbnRlbnQoY29tcG9uZW50RWwpO1xuICAgICAgICBjb25zdCBmb290ZXJFbCA9ICFzY3JvbGxFbCA/IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1mb290ZXInKSA6IG51bGw7XG4gICAgICAgIGlmICghaW5wdXRFbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIXNjcm9sbEVsICYmIGhpZGVDYXJldCAmJiAhaGlkZUNhcmV0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJtRm4gPSBlbmFibGVIaWRlQ2FyZXRPblNjcm9sbChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2Nyb2xsRWwpO1xuICAgICAgICAgICAgaGlkZUNhcmV0TWFwLnNldChjb21wb25lbnRFbCwgcm1Gbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGUvZGF0ZXRpbWUtbG9jYWxlIGlucHV0cyBvbiBtb2JpbGUgZGV2aWNlcyBzaG93IGRhdGUgcGlja2VyXG4gICAgICAgICAqIG92ZXJsYXlzIGluc3RlYWQgb2Yga2V5Ym9hcmRzLiBBcyBhIHJlc3VsdCwgc2Nyb2xsIGFzc2lzdCBpc1xuICAgICAgICAgKiBub3QgbmVlZGVkLiBUaGlzIGFsc28gd29ya3MgYXJvdW5kIGEgYnVnIGluIGlPUyA8MTYgd2hlcmVcbiAgICAgICAgICogc2Nyb2xsIGFzc2lzdCBjYXVzZXMgdGhlIGJyb3dzZXIgdG8gbG9jayB1cC4gU2VlIEZXLTE5OTcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpc0RhdGVJbnB1dCA9IGlucHV0RWwudHlwZSA9PT0gJ2RhdGUnIHx8IGlucHV0RWwudHlwZSA9PT0gJ2RhdGV0aW1lLWxvY2FsJztcbiAgICAgICAgaWYgKCFpc0RhdGVJbnB1dCAmJlxuICAgICAgICAgICAgKCEhc2Nyb2xsRWwgfHwgISFmb290ZXJFbCkgJiZcbiAgICAgICAgICAgIHNjcm9sbEFzc2lzdCAmJlxuICAgICAgICAgICAgIXNjcm9sbEFzc2lzdE1hcC5oYXMoY29tcG9uZW50RWwpKSB7XG4gICAgICAgICAgICBjb25zdCBybUZuID0gZW5hYmxlU2Nyb2xsQXNzaXN0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0LCBzY3JvbGxQYWRkaW5nLCBrZXlib2FyZFJlc2l6ZU1vZGUsIGlzQW5kcm9pZCk7XG4gICAgICAgICAgICBzY3JvbGxBc3Npc3RNYXAuc2V0KGNvbXBvbmVudEVsLCBybUZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5yZWdpc3RlcklucHV0ID0gKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgICAgIGlmIChoaWRlQ2FyZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gaGlkZUNhcmV0TWFwLmdldChjb21wb25lbnRFbCk7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGlkZUNhcmV0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbEFzc2lzdCkge1xuICAgICAgICAgICAgY29uc3QgZm4gPSBzY3JvbGxBc3Npc3RNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxBc3Npc3RNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlucHV0Qmx1cnJpbmcgJiYgSU5QVVRfQkxVUlJJTkcpIHtcbiAgICAgICAgZW5hYmxlSW5wdXRCbHVycmluZygpO1xuICAgIH1cbiAgICAvLyBJbnB1dCBtaWdodCBiZSBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgRE9NIGJlZm9yZSBpb24tZGV2aWNlLWhhY2tzIGRpZC5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIG5lZWQgdG8gbG9vayBmb3IgYWxsIG9mIHRoZSBpbnB1dHMgbm90IHJlZ2lzdGVyZWQgeWV0XG4gICAgLy8gYW5kIHJlZ2lzdGVyIHRoZW0uXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnB1dChpbnB1dCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdpb25JbnB1dERpZExvYWQnLCAoZXYpID0+IHtcbiAgICAgICAgcmVnaXN0ZXJJbnB1dChldi5kZXRhaWwpO1xuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdpb25JbnB1dERpZFVubG9hZCcsIChldikgPT4ge1xuICAgICAgICB1bnJlZ2lzdGVySW5wdXQoZXYuZGV0YWlsKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7IHN0YXJ0SW5wdXRTaGltcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@ionic/core/components/input-shims.js\n"));

/***/ })

}]);